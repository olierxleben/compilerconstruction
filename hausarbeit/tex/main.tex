%
%
\documentclass[11pt]{scrartcl}

% own geometry
%\usepackage[a4paper, left=3cm, right=3cm]{geometry}

\usepackage[ngerman]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{jurabib}
\usepackage{hyperref}

\include{lib/jurabib}
\bibliographystyle{jurabib}

% setup of source code listings
\usepackage{listings}
%\usepackage{courier}
\usepackage{caption}
\lstset{
	basicstyle=\footnotesize\ttfamily,	% default font
	numbers=left,						% line numbers placement
	numberstyle=\tiny,					% line numbers style
	%stepnumber=2,						% line number padding
	numbersep=5pt,						% padding between line numbers and code
	tabsize=2,							% 
	extendedchars=true,         
	breaklines=true,						% line breaks 
	keywordstyle=\color{red},
	frame=b,
	stringstyle=\color{gray}\ttfamily,	% color of strings in code
	showspaces=false,					% visualize spaces
    showtabs=false,						% visualize tabs
    xleftmargin=17pt,
	framexleftmargin=17pt,
	framexrightmargin=5pt,
	framexbottommargin=4pt,
	showstringspaces=false				% visualize spaces in strings        
 }
 
 \lstloadlanguages{% Check docs for further languages ...
         C,
         C++,
         bash,
        %TODO check css in lstlisting package available?!
 }

\setlength{\parindent}{0pt}
\setlength{\parskip}\medskipamount

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% layout the caption ontop of code
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Headings
\usepackage{fancyhdr}
%\fancyhead[R]{\colorbox{blue!20}{ Oliver Erxleben}}
\fancyfoot{}

% Document begins now
\begin{document}

\author{%
	Oliver Erxleben \small(\href{mailto:oliver.erxleben@hs-osnabrueck.de}{oliver.erxleben@hs-osnabrueck.de})\\%
	Sergej Hert \small(\href{mailto:sergej.hert@hs-osnabrueck.de}{sergej.hert@hs-osnabrueck.de})\\%
	Jörn Voßgröne \small(\href{mailto:joern.vossgroene@hs-osnabrueck.de}{joern.vossgroene@hs-osnabrueck.de})\\
	\\%
	Hochschule Osnabr"uck \\%
	Ingenieurswissenschaften und Informatik \\%
	Informatik - Mobile und Verteilte Anwendungen\\
	Compilerbau - Sommersemester 2013 }

\title{\includegraphics[scale=0.75,keepaspectratio]{img/hs_os.png}\linebreak \linebreak Implementierung eines Source-To-Source-Kompilierers zur Optimierung von CSS-Dateien im Webstack}

\maketitle
\thispagestyle{empty}
\tableofcontents
\listoffigures

\lstlistoflistings
\thispagestyle{empty}
\pagebreak
\thispagestyle{empty}

\begin{abstract}
\textbf{Zusammenfassung:}\\ 	
Die vorliegende Ausarbeitung wurde in LaTex verfasst und ist eine gemeinsame Arbeit von Oliver Erxleben, Sergej Hert und Jörn Voßgröne an der Hochschule Osnabrück / University of Applied Sciences im Fachbereich Ingenieurswissenschaften und Informatik für das Fach Compilerbau im Sommersemester 2013. Die Arbeit beschäftigt sich mit der Optimierung von Cascading Stylesheets für Webseiten.\\
\\
Die Arbeit gliedert sich in mehrere Abschnitte. Im ersten Kapitel wird der Hintergrund des Themas beschrieben und es werden wichtige Fachbegriffe definiert. Ausserdem werden die Anforderungen an die Software aufgestellt.\\
Im zweiten Teil, Cascading Style Sheets, werden die Sprache, dessen Verwendung, sowie die zugrundeliegende Grammatik erläutert und es wird beschrieben wie Webbrowser diese interpretieren.\\
Der dritte Teil erläutert das Vorgehen der Optimierung. Neben der Syntaxanalyse und dem Optimieren der Knoten, wird auch die Implementierung eines Kommandozeilenwerkzeugs zur Steuerung der Optimierungen erläutert.\\
Der Abschnitt Messungen erklärt das Vorgehen für Tests. \\ % TODO: Abschnitt 4 erweitern
Im abschließenden Abschnitt wird die Arbeit resümiert, das Ergebnis zusammengefasst und gewonnene Erfahrungen geschildert.   
\end{abstract}

\pagebreak
% set new page style

\pagestyle{fancy}
\setcounter{page}{1} 

\section{Einleitung}
%TODO: überarbeiten / erweitern 
\subsection{Motivation}
Im Alltag eines Frontend-Entwicklers, eines Mitarbeiters an einem Web-Projekt oder des Entwicklers für das grafische User Interface kommt es nicht selten vor, dass die Beschreibung der grafischen Elemente durch Cascading Stylesheets geschieht. Noch seltener sind diese Style Angaben fehlerfrei. Sei es aufgrund von Zeitdruck, unterschiedlichen Entwicklern oder durch nachträgliches Bugfixing, oft sind CSS-Regeln inkonstistent aufgestellt, zum Beispieln existieren noch Regeln, die garnicht mehr im DOM der Seite zu finden sind. Es werden Regeln mehrmals überschrieben und es wird nicht auf Optimierung von Selektoren geachtet. 

Seit 2010 berücksichtigt der Page Ranking Algorithmus von Google auch die Ladezeiten für Websites. Seiten, die neben SEO ein gutes Page Ranking erhalten, werden demnach auch durch ihre Ladezeiten bestimmt. Die Ladezeiten spielen zwar im Vergleich mit SEO nur eine kleine Rolle, können aber zu einem besseren Ergebnis beitragen (Weite Informationen: http://googlewebmastercentral.blogspot.de/2010/04/using-site-speed-in-web-search-ranking.html).
Ladezeiten von mobilen Websites und Web-Anwendungen bzw. Seiten, die über mobile Internetverbindungen geladen werden, sollten schnell und nur wenig Daten übertragen, um ein konsistentes Benutzererlebnis zu gewährleisten. Statistiken zeigen, dass Benutzer auf Websites eher verbleiben wenn diese schnell geladen werden und der Benutzer schnell Informationen abrufen oder mit der Anwendung interagieren kann.

Im Rahmen der Hausarbeit für das Fach Compilerbau im Sommersemester 2013 im Master-Studiengang Informatik - Verteilte und Mobile Anwendungen an der Hochschule Osnabrück / University of Applied Sciences soll ein Werkzeug entwickelt werden mit dem sich Stylesheets optimieren lassen. Dazu soll ein Kommandozeilentool entwickelt werden, womit CSS-Optimierungen gesteuert und ausgegeben werden können. 
\subsection{Zielsetzung}
\subsection{Begriffsdefinitionen}
\subsubsection{Web-Stack / Web-Anwendungen}
\subsubsection{Document Object Model}

\pagebreak
\section{Cascading Style Sheets}
\subsection{Einführung in CSS}

Cascading Stylesheets gilt aktuell als Standard-Stylesheetsprache für Websites. Es findet aber auch Verwendung in anderen Umgebungen, wie zum Beispiel JavaFX. Mit CSS ist es möglich Ausgabemedien unterschiedliche Darstellung vorzugeben. Beispielsweise soll einen Hyperlink\footnote{Hyperlink:} beim Druck einer Seite in einer anderen Farbe dargestellt werden oder die Elemente einer Bildergalerie sollen auf Geräten mit kleinerer Auflösung (wie etwa Tablets oder Smartphones) in einer anderen Darstellung gelistet werden, als bei einem Display mit FullHD-Auflösung.  

\subsection{Revisionen und Probleme}
Die Entwicklung von CSS wurde 1993 begonnen und hat nach mehreren Versionen 1995 den Stand der ersten Version erreicht. 1998 wurde die Version 2 vorgestellt. Diese ist aktuell und wurde bis heute allerdings von keinem der Mainstream-Browser vollständig implementiert. Einige Browser setzen große Teile des CSS2, bzw. CSS2.1-Standards korrekt um. Es kann aber zu Problemen bei unterschiedlichen Browsern führen. 2011 wurde die Recommandation für CSS 2.1 veröffentlicht. 

Die aktuelle Entwicklung für den dritten Standard von CSS begann bereits 2000. Zu den Neuerungen in dieser Revision gehören vor allem der modulare Aufbau, womit CSS-Eigenschaften nun schrittweise entwickelt werden können. 

\subsection{Allgemeiner Aufbau}

Damit eine Optimierung von bestehenden CSS-Quelltext durchgeführt werden kann, muss zuvor analysiert werden wie ein Browser CSS verarbeitet und wie Kaskadierung im Browser genutzt wird um Style-Informationen zu verknüpfen.

Eine CSS-Datei besteht aus einer Menge von Anweisungen die das Layout einzelner Elemente (mit bestimmten Identifier), Klassen von Elementen oder allgemein gültige Elemente.

Der allgemeine Aufbau einer CSS-Regel wird im Listing \ref{css_basics} veranschaulicht.   
%TODO comment in css style
\begin{lstlisting}[label=css_basics,language=bash, caption=Aufbau einer CSS-Regel][!h]
a {
    background:#000;
    color: #fff;
}  
#special {
    border: 1px solid red;
}

.left, top.myClass {
    border: 1px dotted green;
}
\end{lstlisting}

Im Listing sind drei Regeln gegeben. Die erste Regel wird für ein HTML-Element angewendet. Jedes a-Element (Links im Browser) werden schwarz unterlegt und der textliche Inhalt des Elements wird weiß dargstellt. Bei dem zweiten Element wird eine Regel auf ein Element mit der ID \textbf{special} angwendet. Dies erhält einen durchgehenden roten Rahmen um den Inhalt des Elements. Die dritte Regeln legt eine gepunktete grüne Linie um den Inhalt der Elemente mit der Klasse \textbf{left}, sowie der HTML-Elemente top mit der zugewiesen Klasse \textbf{myClass}.  

Wie interpretiert der Browser allerdings die vordefinierten Werte mit den kaskadierten Elementen der Stylesheet-Datei und wie berechnet sich daraus der zusammengesetzte Wert? Dazu sei die Abbildung [] gegeben. %TODO: Abbildung für CSS-Berechnung im Browser 



\subsubsection{Browserunterstützung}
% TODO: Table
\subsection{Syntax}
Die Syntax von CSS wurde von der W3C 
\cite{w3c_css_syntax}
\subsection{Grammatik}
Die zugrundeliegende Grammatik stammt von der Seite des W3C (Details, siehe: \cite{w3c_css_grammar}). Dies entspricht im Wesentlichen der Grammatik für die CSS Version 2.1. Das Listing \ref{css_grammar} zeigt die Grammatik des W3C. 

\begin{lstlisting}[label=css_grammar,language=bash, caption=Grammatik von CSS nach W3C][!h]
stylesheet
  : [ CHARSET_SYM STRING ';' ]?
    [S|CDO|CDC]* [ import [ CDO S* | CDC S* ]* ]*
    [ [ ruleset | media | page ] [ CDO S* | CDC S* ]* ]*
  ;
import
  : IMPORT_SYM S*
    [STRING|URI] S* media_list? ';' S*
  ;
media
  : MEDIA_SYM S* media_list '{' S* ruleset* '}' S*
  ;
media_list
  : medium [ COMMA S* medium]*
  ;
medium
  : IDENT S*
  ;
page
  : PAGE_SYM S* pseudo_page?
    '{' S* declaration? [ ';' S* declaration? ]* '}' S*
  ;
pseudo_page
  : ':' IDENT S*
  ;
operator
  : '/' S* | ',' S*
  ;
combinator
  : '+' S*
  | '>' S*
  ;
unary_operator
  : '-' | '+'
  ;
property
  : IDENT S*
  ;
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration? [ ';' S* declaration? ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ]? ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*]? ')' ]
  ;
declaration
  : property ':' S* expr prio?
  ;
prio
  : IMPORTANT_SYM S*
  ;
expr
  : term [ operator? term ]*
  ;
term
  : unary_operator?
    [ NUMBER S* | PERCENTAGE S* | LENGTH S* | EMS S* | EXS S* | ANGLE S* |
      TIME S* | FREQ S* ]
  | STRING S* | IDENT S* | URI S* | hexcolor | function
  ;
function
  : FUNCTION S* expr ')' S*
  ;
/*
 * There is a constraint on the color that it must
 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
 */
hexcolor
  : HASH S*
  ;
\end{lstlisting}

\pagebreak
\section{Optimierung}
\subsection{Kommandozeilentool}
\subsection{Syntaxanalyse}
\subsection{Knotenoptimierung}
\subsubsection{}

\pagebreak
\section{Messungen}
\subsection{Grundlage}
\fancyhead[R]{}

\pagebreak
\section{Ergebnis}

\thispagestyle{empty}

\renewcommand*{\biburlprefix}{(URL: }
\renewcommand*{\biburlsuffix}{)}

\pagebreak
\addcontentsline{toc}{section}{Literaturverzeichnis} % Eintrag ins Inhaltsverzeichnis
\bibliography{bib/bib}

\appendix
\include{attachment/vm}

\end{document}
